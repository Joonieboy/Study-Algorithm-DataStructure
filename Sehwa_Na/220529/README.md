# 22/05/29 알고리즘 문제 풀이


- 공통문제

|`문제`|`분류`|`난이도`|
|--|--|--|
|[1000: A+B](https://www.acmicpc.net/problem/1000)|수학, 구현, 사칙연산|브론즈5|
|[1330: 두 수 비교하기](https://www.acmipc.net/problem/1330)|수학, 구현, 사칙연산|브론즈4|


- 개인문제

|`문제`|`분류`|`난이도`|
|--|--|--|
|[1003: 피보나치 수열](https://www.acmicpc.net/problem/1003)|다이나믹 프로그래밍|실버3|


### 개인문제 풀이
- 피보나치 수열 : 0 1 1 2 3 5 8 .... 과 같이 n번째 원소가 n-1번째 원소 + n-2번째 원소인 수열
- 피보나치 수열을 구현하는 가장 Basic한 방법 : 재귀함수 호출을 통한 구현
- ![image](https://user-images.githubusercontent.com/38839314/170068109-3e5b127a-ebef-4361-a735-0b4a5a1a9268.png)
- 이미지 출처 : https://shoark7.github.io/assets/img/algorithm/fibbonacci-recurisive.png
- 재귀함수 호출로 구현하면 시간복잡도가 보통의 경우 O(n^2) 인데, 동적계획법(다이나믹 프로그래밍, DP)의 메모이제이션으로 구현하면 O(n)으로 줄일 수 있음
- C++의 Vector를 통해 for문을 돌면서 N번째 원소가 Vector의 N-1번째, N-2번째를 더한 값을 저장하도록 함
- for문을 한번 돌게 되므로, 시간복잡도가 O(n)
- 문제에서 0과 1이 각각 몇번 출력되는지 구하라고 함 -> 피보나치 수열의 N-1번째, N번째 원소의 값을 구하라는 말과 같음
- Vector에서 N-1번째 원소와 N번째 원소를 차례대로 출력하면 끝
